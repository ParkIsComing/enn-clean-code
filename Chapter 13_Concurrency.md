### Intro

단일 스레드에서 실행되는 코드는 작성하기 쉽다. 겉으로는 잘 동작하는 것처럼 보이는 멀티 스레드 코드를 작성하는 것도 쉽다.

이 챕터에서는 멀티 스레드 프로그래밍의 필요성과 어려움에 대해 논의한다. 또한, 멀티 스레드 프로그래밍의 어려움에 대한 해결 방안과 깨끗한 코드를 작성하는 방법, 테스트 방법을 소개하고자 한다.

### 1. 동시성이 필요한 이유

동시성은 결합을 없애는 전략이다. 

단일 스레드에서의 "무엇을 할 것인가"와 "언제 끝날 것인가"간의 의존성을 분리하여 준다. 

이를 분리하면 애플리케이션의 구조와 효율성 개선에 큰 효과가 있다.

구조 개선의 좋은 예는 웹 어플리케이션이 표준으로 사용하는 Servlet 모델이다. 이론적으로, Servlet 개발자는 요청을 개별적으로 처리하는 데에만 신경을 쓸 수 있어 요청 큐를 직접 관리하는 부담을 덜 수 있다. 물론, Servlet이 제공하는 동시성은 완벽하지 않지만 Servlet 모델이 제공하는 구조적인 이점은 그 자체로 가치가 있다.

작업 처리량 또한 향상될 수 있다. 한 유저의 요청을 처리하는 데에 1초가 필요한 시스템을 생각해 보자. 사용자가 소수라면 이 시스템은 그럭저럭 괜찮은 퍼포먼스를 보여줄 것이다. 하지만 유저가 늘어날수록 모든 유저는 자신보다 먼저 도착한 요청이 끝날 때까지 기다려야 하기 때문에 시스템이 응답하는 속도는 점점 늦어질 것이다. 이러한 경우 여러 유저를 동시에 처리한다면 처리량을 향상시킬 수 있다.

*미신과 오해*

- 동시성은 항상 성능을 향상시킨다.
    - 동시성은 여러 스레드 혹은 여러 프로세서가 대기 시간을 공유할 수 있는 경우에만 퍼포먼스를 향상시킨다. 하지만 이러한 경우는 드물다.
- 동시성을 구현해도 시스템 설계는 변하지 않는다.
    - 일반적으로 "무엇"과 "언제"를 분리하는 작업은 보통 시스템의 구조에 큰 영향을 미친다.
- 웹 또는 EJB와 같은 컨테이너를 사용한다면 동시성 문제들은 신경 쓸 필요가 없다.
    - 실제로는 컨테이너가 어떤 일을 하는 지에 대해 알아야 하며 동시 수정과 데드락을 해결하는 방법을 알아야 한다.

*동시성과 관련된 타당한 생각 몇 가지*

- 동시성은 퍼포먼스, 코드 작성 양쪽 모두에 다소 오버헤드를 일으킨다.
- 동시성은 간단한 문제 해결일 때에도 간단하지 않다.
- 동시성 관련 버그는 재현하기가 어렵기 때문에 일회성 문제 여겨 무시한다.
- 동시성 문제에는 보통 근본적인 설계 개편이 필요하다.

### 2. 난관

동시성을 구현하기 어려운 이유?

```java
public class ClassWithThreadingProblem {
    private int lastIdUsed;
    
    public ClassWithThreadingProblem(int lastIdUsed) {
        this.lastIdUsed = lastIdUsed;
    }
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}

public static void main(String args[]) {
    final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(42);
    
    Runnable runnable = new Runnable() {
        public void run() {
            classWithThreadingProblem.getNextId();
        }
    };
    
    Thread t1 = new Thread(runnable);
    Thread t2 = new Thread(runnable);
    t1.start();
    t2.start();
}
```

위 코드가 만들 수 있는 결과는 총 3가지이다.

- t1이 43을, t2가 44를 가져간다. lastIdUsed는 44이다. (O)
- t1이 44을, t2가 43를 가져간다. lastIdUsed는 44이다. (O)
- t1이 43을, t2가 43를 가져간다. lastIdUsed는 43이다. (X)

위의 getNextId() 메서드는 8개의 자바 byte-code로 변환되며, 이를 두 스레드에서 실행하게 되면 총 12,870개의 코드 조합을 낼 수 있다. 대다수 경로가 올바른 결과를 내놓지만 일부의 몇몇 조합이 마지막 결과를 낳게 된다.

### 3. 동시성 방어 원칙

- 단일 책임 원칙 (SRP)
    
    동시성은 복잡성 하나만으로 분리할 이유가 충분하다. (변경이 발생하기 쉬움)
    
    아래는 동시성 코드를 구현할 때 고려해야 할 사항들이다.
    
    - 동시성 *관련 코드*는 *개발*, 변경, 조율 시 다른 코드와 분리된 생명 주기를 가진다.
    - 동시성 *관련 코드*는 독자적인 난관이 있다.
    - 잘못 작성된 동시성 코드는 여러 방식으로 문제를 발생시킬 수 있다.
    
    **권장사항:** *Concurrency 관련 코드는 다른 코드들과 분리하라.*
    
- 따름 정리
    - 자료 범위를 제한하라
        
        공유 객체를 두 스레드에서 동시에 수정하는 중 간섭이 발생할 수 있으며 이는 예기치 못한 결과를 야기할 수 있다. 이러한 *critical section*을 보호하는 한 가지 방법은 synchronized 키워드를 사용하는 것이다. *Critical section*의 수는 가능한 적게 만들어야 하며 이를 어길 경우 여러 문제가 발생하기 쉽다.
        
        **권장사항:** *자료 캡슐화를 기억하며 공유 자원에 접근하는 코드를 최대한 줄여라.*
        
    - 자료 사본을 사용하라
        
        공유 자원 문제를 해결하는 좋은 방법 중 하나는 애초에 공유 자원을 사용하지 않는 것이다. 읽기 전용으로 사용될 경우 자원의 복사본을 사용하게 하는 방법이 있다. 경우에 따라서는 복사본을 여러 스레드에 전달하고 작업을 수행하게 해 그 결과를 단일 스레드에서 수집해 사용하는 것도 가능하다.
        
        이 때, 객체의 복사에 드는 비용과 시간을 걱정할 수도 있다. 하지만 객체의 복사본을 사용함으로써 동기화를 피할 수 있다면, 객체를 복사할 때 발생하는 객체 생성 및 가비지 컬렉션에 드는 비용은 공유 자원 동기화에 필요한 비용보다 일반적으로 적은 비용으로 문제를 해결하게 해 준다.
        
        (객체 복사 cost < 공유 자원 동기화 cost)
        
    - 스레드는 가능한 독립적으로 구현하라
        
        스레드 코드를 공유 자원을 사용하지 않는 독립된 세계로 만든다면 동기화 문제는 없어지게 된다.
        
        예를 들어, HttpServlet 클래스를 상속받는 클래스는 doGet, doPost와 같은 메서드에서 필요한 파라미터를 받아 처리한다. 이는 각 Servlet이 각자의 세계에 있는 것처럼 작동하게 도와주며, 지역 변수를 사용하는 한 동기화 문제는 발생하지 않게 된다. 물론 대부분의 Servlet들은 데이터베이스 연결과 같은 공유 자원이 필요하긴 하다.
        
        **권장사항:** *데이터를 독자적인 스레드-더 나아가 각각의 프로세서-에서 사용될 수 있게 구분하라.*
        
    

### 4. 라이브러리를 이해하라

자바 5 버전 이상에서 스레드 관련 코드 작성 시 아래의 사항들을 고려하라.

- thread-safe 컬랙션을 사용하라.
- 연관이 없는 작업 수행시 executor 프레임워크를 사용하라.
- 가능하면 nonblocking 방법을 사용하라.
- 일부 라이브러리 클래스들은 thread-safe하지 않다.

*스레드 환경에 안전한 컬렉션*

java.util.concurrent 패키지는 멀티 스레드 환경에서 사용할 수 있는 컬랙션들을 제공한다. 예를 들어, ConcurrentHashMap의 경우 일반 HashMap보다 대부분의 상황에서 더 좋은 퍼포먼스를 제공한다. 

고급 concurrency 디자인 구현을 위한 컴포넌트

- ReentrantLock : 한 메서드에서 잠그고 다른 메서드에서 해제될 수 있는 lock이다.
- Semaphore : 전통적인 세마포어(갯수를 셀 수 있는 lock)의 구현체이다.
- CountDownLatch : 기다리는 모든 스레드들을 해제하기 전 특정 횟수의 이벤트가 발생하는 것을 기다리게 할 수 있는 lock이다. 모든 스레드가 거의 동시에 시작될 수 있게 도와줄 수 있다.

### 5. 실행 모델을 이해하라

- 생산자-소비자
    
    하나 이상의 생산자가 정보를 버퍼 혹은 큐에 넣는다. 하나 이상의 소비자가 버퍼 혹은 큐에서 정보를 가져와 사용한다. 생산자와 소비자 사이에 있는 큐는 한정된 자원이므로 생산자는 큐에 남는 공간이 생길 때까지, 소비자는 큐에 작업물이 하나라도 생길 때까지 기다려야 한다. 생산자는 큐에 작업물을 넣고 소비자에게 "큐가 비어있지 않다"는 신호를 보내고 소비자는 큐에서 작업물을 꺼낸 후 "큐가 가득차 있지 않다"는 신호를 보낸다. 그 전까지 둘은 신호를 기다린다.
    
- 읽기-쓰기
    
    주로 읽기 스레드를 위한 정보로 사용되며, 가끔 쓰기 스레드에 의해 업데이트 될 때, 공유 자원의 처리량이 문제가 된다. 처리량을 강조해 읽기 스레드가 상대적인 우선권을 가지게 되면 쓰기 스레드는 기아 상태에 빠지며 공유 자원은 정체된 정보로 가득차게 된다. 반대로 쓰기 스레드가 우선권을 가지면 처리량이 줄어들게 된다. 읽기-쓰기 문제는 이 둘 사이의 균형을 맞추며 동시 업데이트를 방지하는 것을 주안점으로 둔다.
    
- 식사하는 철학자들
    
    원탁을 둘러싼 여러 명의 철학자들이 있다. 각 철학자의 왼쪽에 포크가 놓여 있으며 테이블의 중앙에 큰 스파게티 한 그릇이 놓여 있다. 그들은 배가 고파지기 전까지 각자 생각을 하며 시간을 보낸다. 배가 고파지면 그들은 자신의 양쪽에 놓여 있는 포크 2개를 잡고 스파게티를 먹는다.
    
    철학자는 포크 2개가 있어야만 스파게티를 먹을 수 있다. 그렇지 않다면 옆 사람이 포크를 다 사용하기 전까지 기다려야 한다. 스파게티를 먹은 철학자는 다시 배가 고파질 때까지 포크를 놓고 있게 된다.
    
    위 상황에서 철학자를 스레드로, 포크를 공유 자원으로 바꾸게 되면 이는 자원을 놓고 경쟁하는 프로세스와 비슷한 상황이 된다. 잘 설계되지 않은 시스템은 deadlock, livelock, 처리량 저하, 효율성 저하 문제에 맞닥뜨리기 쉽다.
    

### 6. 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

동기화된 메서드 간의 의존성은 찾아내기 어려운 버그를 일으킬 수 있다. 그래서 자바는 개별 메서드를 보호하는 synchronized 개념을 제공한다. 하지만 한 클래스에 두 개 이상의 synchronized 메서드가 존재하면 문제를 일으킬 수도 있다. 따라서 이를 피하는 것이 좋지만 그게 어려운 상황이라면 아래의 방법들을 사용할 수 있다.

- **클라이언트 기반 잠금**: 클라이언트가 첫 메서드를 부르기 이전부터 마지막 메서드를 부른 다음까지 서버를 잠근다.
- **서버 기반 잠금**: 서버에 서버(자신)을 잠그고 모든 동작을 수행한 후 잠금을 푸는 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
- **중계된 서버**: 잠금을 수행하는 중계자를 작성한다. 이는 기본적으로 서버 기반 잠금이지만 기존의 기존 서버를 변경할 수 없는 상황에 사용할 수 있는 방법이다.

### 7. 동기화하는 부분을 작게 만들어라

Synchronized로 수행되는 락은 스레드 지연과 오버헤드를 만들기 때문에 가능한 한 적게 사용하는 것이 좋다.

반면, critical section은 꼭 보호되어야 한다. 따라서 critical section는 최대한 줄이는 것이 좋다. 그렇지만 줄인답시고 하나의 큰 critical section르 구현하는 것은 안된다.

### 8. 올바른 종료 코드는 구현하기 어렵다

영구적으로 동작하는 코드의 작성은 잠시 동작하고 깔끔하게 끝나는 코드의 작성과는 다르다.

깔끔하게 끝나는 코드는 작성하기 어렵다. 스레드가 오지 않을 시그널을 기다리는 데드락이 발생하기 때문이다.

데드락에 걸린 자식 스레드의 수행이 끝나길 기다리는 부모 스레드의 경우를 생각해 보라. 자식은 데드락에 걸려 멈춰 있고 부모는 이를 끝없이 기다리게 된다.

이와 같은 코드를 작성할 경우 정상적인 종료가 이루어질 때까지 많은 시간이 소요된다.

**권장사항:** *개발 초기부터 시스템 종료에 대해 고민하고 구현하라. 이 작업은 생각보다 오래 걸리고 어렵기 때문에 이미 나온 알고리즘들을 검토하라.*

### 9. 스레드 코드 테스트하기

테스트는 정확성을 보장하지는 않지만 위험을 낮춘다.

멀티 스레드의 경우 고려해야 할 상황은 급격하게 복잡해진다.

**권장사항:** *문제를 노출하는 테스트 케이스를 만들어서 프로그램과 시스템 설정, 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라.*

아래는 이때 고려할 사항들에 대한 구체적인 지침이다.

- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하기
    
    멀티 스레드 코드는 일반적으로 발생할 수 없어 보이는 문제를 발생시키므로 직관적으로 이해하기 어렵다. 그리고 굉장히 드물게 발생하며 실패를 재현하기가 아주 어렵다. 그래서 많은 개발자는 이를 일회성 문제로 치부하고 무시하는데, 그것이 축적되어 큰 문제가 말생한다.
    
    **권장사항:** *시스템 실패를 일회성이라 치부하지 마라.*
    
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 작성
    
    스레드 밖에서 잘 동작하는 코드를 먼저 작성하라. 이는 스레드에서 사용될 POJO(평범한 자바 객체)를 뜻한다. POJO는 스레드와 의존관계가 없어 스레드 밖에서도 테스트할 수 있다. POJO에 넣는 코드는 많을수록 좋다.
    
    **권장사항:** *스레드 관련 버그와 그렇지 않은 버그를 동시에 잡으려 하지 마라. 작성한 코드가 스레드 밖에서 잘 작동하는지 먼저 체크하라.*
    
- 다중 스레드를 쓰는 부분은 다양한 환경에 끼워 넣을 수 있게 구현하라
    - 단일 스레드, 멀티 스레드 등 다양한 환경에서 실행시켜보고 실행 중 스레드 수를 바꿔본다.
    - 스레드 코드를 실제 환경과 테스트 환경에서 실행시킨다.
    - 테스트 코드를 다양한 속도로 돌려본다.
    - 반복 수행할 수 있도록 구현한다.
- 다중 스레드를 쓰는 부분은 상황에 맞게 조율할 수 있도록 작성하기
- 프로세스 수보다 많은 스레드 돌리기
    
    시스템이 작업을 스와핑할 때에도 문제는 발생한다. 스와핑을 발생하게 하기 위해 프로세서 수보다 많은 스레드를 실행해 보라. 스와핑이 잦을수록 빠뜨린 critical section이나 데드락을 찾을 확률이 높아지게 된다.
    
- 다른 플랫폼에서 돌려보기
    
    어떤 실패 시연 테스트는 OSX에서는 자주 발생했지만 Windows XP에서는 OSX에서만큼 자주 발생하지 않았다. 이처럼 운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라질 수 있기 때문에 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트가 수행되어야 한다.
    
- 코드에 보조 코드를 넣어 돌리기
    
    스레드 관련 문제는 수많은 실행 경로 중 얼마 안되는 확률로 발생하기 때문에 드물게 발생하며 재현하기 어렵다. 이 실행 경로를 조작해 스레드 문제가 발생할 확률을 높이는 보조 코드 구현에는 두 가지 방법이 있다.
    
    - 직접 구현하기
        
        Object.wait(), Object.sleep(), Object.yield(), Object.priority()등의 메서드를 사용해 실행 경로를 변경함으로써 코드의 문제를 발견하는 방법이다.
        
        ```java
        public synchronized String nextUrlOrNull() {
            if(hasNext()) {
                String url = urlGenerator.next();
                Thread.yield();
                // inserted for testing.
                updateHasNext();
                return url;
            }
            return null;
        }
        ```
        
        만약 위 코드에서 문제가 발생한다면 이는 yield()를 추가해 생긴 문제가 아니라 이미 존재하던 문제를 명백히 만든 것 뿐이다.
        
    - 자동화
        
        Aspect-oriented Framework, CGLib, ASM등을 통해 프로그램적으로 코드를 조작하는 방법이다.
        
        ```java
        public class ThreadJigglePoint {
            public static void jiggle() { }
        }
        
        public synchronized String nextUrlOrNull() {
            if(hasNext()) {
                ThreadJiglePoint.jiggle();
                String url = urlGenerator.next();
                ThreadJiglePoint.jiggle();
                updateHasNext();
                ThreadJiglePoint.jiggle();
                return url;
            }
            return null;
        }
        ```
        
         ThreadJiglePoint.jiggle() 호출은 'sleep', 'yield'등을 무작위로 선택하게 할 수 있다. 때로는 아무것도 하지 않는다.
        

### 결론

다중 스레드 코드는 제대로 작성하기 어렵다. 간단했던 코드가 여러 스레드와 공유 자원으로 엮이게 되면 끔찍한 결과를 낳게 된다. 동시성 코드는 엄격한 기준으로 clean하게 작성하라. 그렇지 않으면 찾기 어렵고 희귀한 오류를 만나게 될 것이다.

먼저, SRP를 숙지하라. 시스템을 최대한 POJO단위로 잘라 스레드를 아는 코드와 스레드를 모르는 코드로 나누어라. 스레드 관련 코드를 테스트할 때에는 그 이외의 것들은 제외하고 스레드 관련 문제만 테스트하라. 스레드 코드는 최대한 작아져야 한다는 뜻이다.

한 공유 자원에 대한 멀티 스레드 수행, 공유되는 자원 풀 등 동시성 오류를 일으킬 수 있는 부분에 대해 인지하라. 깔끔하게 종료되게 하는 문제나 반복문 탈출과 같은 문제는 특히 성가실 수 있다.

라이브러리를 이해하고 기본적인 알고리즘을 이해하라. 라이브러리가 제공하는 기능이 어떻게 문제를 해결하는지 이해하라.

잠가야 할 필요가 있는 부분을 찾는 방법을 배우고 잠가라.  잠긴 구간에서 또 다른 잠긴 구간을 호출하는 것을 피하라. 이는 "무엇이 공유되고 안되고"에 대한 깊은 이해를 요구한다. 공유 객체의 갯수와 공유 영역을 최소한으로 줄여라. 클라이언트가 공유 객체의 상태를 관리하는 대신 공유 객체의 설계를 변경하라.

문제는 돌연 발생할 것이다. 그렇지 않은 문제들은 보통 일회성 문제로 치부된다. 그러므로 스레드 관련 코드의 테스트는 여러 설정, 환경에서 반복적이고 지속적으로 수행되어야 한다.

시간을 들여 보조 코드를 추가하면 문제점을 찾을 확률은 높아질 것이다. 직접 코드를 작성할 수도 있고 자동화 툴을 사용할 수도 있다. 출시하기 전까지 최대한 오래 테스트 해야 할 것이다.

Clean한 접근 방식을 사용한다면, 제대로 된 코드를 만들어낼 가능성은 급격히 올라갈 것이다.
