# 부록A: 동시성2
## 클라이언트/서버 성능 개선

- 애플리케이션이 어디서 시간을 보내는지 알아야 함. 가능한 경우는 아래의 두가지 

1. I/0
- EX) 소켓 사용 / DB 연결 / 가상 메모리 스와핑 등
- 해결책: **동시성**을 이용한 성능 개선(**쓰레드** 추가)
  - 쓰레드를 관리하는 코드는 쓰레드만 관리하도록 한다.
  - 쓰레드 관리 책임을 클래스로 분리하면 쓰레드 관리 전략이 변해도 전체 코드에 미치는 영향이 작아지고, 다른 책임에 간섭하지 않으며, **단일책임원칙(SRP)**를 지킬 수 있다.
2. 프로세서
-> EX) 수치 계산 / 정규 표현식 처리 / 가비지 컬렉션
-> 해결책: 새로운 하드웨어를 추가해 성능 개선

## 가능한 실행 경로
- 자바 컴파일러는 바이트 코드를 생성한다. 개발자가 작성한 코드 한 줄은 바이트 코드 명령 8개로 이뤄져있다.
- 만약 N개의 쓰레드가 번갈아 연산을 실행한다면 N개의 쓰레드는 각자의 바이트 코드 명령 8개를 뒤섞어 실행할 수 있다.
- 원자적 연산이 아닌 연산은 실행 중에 다른 쓰레드가 끼어들어 값을 변경할 수 있다. 이때 **원자적 연산**은 중단이 불가능한, 즉 중간에 다른 쓰레드가 끼어들 수 없는 연산을 말한다. 예를 들어, 할당 연산은 원자적 연산이지만 전처리 증가 연산( 예:`++lastID` )은 원자적 연산이 아니다.
- 따라서, 원자적 연산을 고려하여 쓰레드가 서로의 작업을 덮어쓰는 과정을 이해하고 `synchronized`등의 방법을 사용해 다중 쓰레드가 낳을 수 있는 문제를 해결한다. 

## 쓰레드를 차단하지 않는 방법
- 쓰레드를 차단하지 않는 방식은 여러 쓰레드가 같은 값을 수정해서 문제를 일으키는 경우가 드물다는 가정에서 출발한다.
- 자바5는 AtomicBoolean, AtomicInteger, AtomicReference를 포함한 다양한 클래스를 사용해 쓰레드를 차단하지 않고 값을 갱신할 수 있도록 지원한다.

## 메세드 사이에 존재하는 의존성을 조심하라


```java
public class IntegerIterator implements Iterator<Integer> {
    private Integer nextValue = 0;

    public synchronized boolean hasNext() {
        return nextValue < 100000;
    }

    public synchronized Integer next() {
        if (nextValue == 100000)
            throw new IteratorPastEndException();
        return nextValue++;
    }

    public synchronized Integer getNextValue() {
        return nextValue;
    }
}
```
- 위의 코드에서 쓰레드 2개가 IntegerInterator라는 인스턴스 하나를 공유한다고 가정하자.
- 메서드 간의 의존성이 문제가 되는 경우는 다음과 같다.
  1. 쓰레드1이 hasNext()를 호출해 true얻음
  2. 쓰레드2가 끼어들어 마찬가지로 hasNext()를 호출해 true얻음
  3. 쓰레드2가 이어서 next()를 호출하여 nextValue값이 증가하고, 그 결과 nextValue는 hasNext() 메소드가 true를 리턴하기 위한 조건을 더이상 만족하지 않게 됨
  4. 실행을 재개한 쓰레드1은 hasNext()가 여전히 true라고 생각해 next()를 호출
- 이러한 문제가 생긴 경우 해결방안은 다음과 같다.
  1. 실패를 용인
     - 클라이언트가 예외를 받아 처리 
  2. 클라이언트를 바꿔 문제 해결(클라이언트-기반 잠금 메커니즘 구현)
     - 모든 클라이언트가 synchronized를 이용해 IntegerIterator 객체에 락을 건다.
     - 단점: 모든 클라이언트가 잠금 정책을 구현해야 함
  3. 서버를 바꿔 문제 해결(서버-기반 잠금 메커니즘 구현)
     - 잠금 메커니즘을 서버에 구현 
     - 장점: 클라이언트는 자유롭게 객체 사용 가능 & 클라이언트에 잠금 코드를 추가하지 않아도 됨
     
## 데드락
### 데드락의 발생 조건
1. 상호 배제(Mutual exclusion)
2. 잠금 & 대기(Lock & Wait)
3. 선점 불가(No preemption)
4. 순환 대기(Circular Wait)

#### 상호 배제
- 여러 스레드가 한 자원을 공유하는데 그 자원은 여러 스레드가 동시에 사용할 수 없고 개수가 제한적일 때
#### 잠금 & 대기
- 한번 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유하여 작업이 끝날 때까지 점유한 사원을 내놓지 않을 때
#### 선점 불가
- 한 스레드가 다른 스레드로부터 자원을 빼앗지 못할 때. 오직 자원을 점유하고 있는 스레드가 스스로 내놓을 때만 다른 스레드가 해당 자원을 점유할 수 있음.
#### 순환 대기
- 예시) 스레드1,2와 자원 1,2가 있다고 가정.
  - 스레드1: 자원1 점유중 & 자원2 필요로 함
  - 스레드2: 자원2 점유중 & 자원1 필요로 함
   
### 데드락 해결방법
#### 상호 배제 조건 깨기
- 동시에 사용해도 괜찮은 자원 사용
- 스레드 수 이상으로 자원 수를 늘림
- 자원을 점유하기 전에 스레드들이 필요로 하는 자원이 모두 있는지 확인
#### 잠금 & 대기 조건 깨기
- 만약 하나의 쓰레드라도 점유하지 못한다면 지금까지 점유한 자원을 모두 내놓고 처음부터 다시 시작
  - 한계:
    - starvation: 한 쓰레드가 계속해서 필요한 자원을 점유하지 못함
    - livelock: 여러 쓰레드가 한꺼번에 잠금 단계로 진입하여 계속해서 자원을 점유했다 내놨다를 반복함
    
#### 선점 불가 조건 깨기
- 필요한 자원이 다른 쓰레드로 인해 잠겼다면 해당 쓰레드에게 풀어달라 요청함 
- 그 소유 쓰레드가 다른 자원을 기다리던 중이었다면 자신이 가진 자원을 모두 풀어주고 처음부터 다시 시작함
#### 순환 대기 조건 깨기
- 모든 쓰레드가 동의한 순서대로만 자원을 할당하면 순환 대기는 생길 수 없음

## 몬테카를로 테스트
- 코드의 쓰레드 문제를 찾아내기 위한 테스트 코드 작성 기법 중 하나
- 방법
  - 조율 가능하게 유연한 테스트를 만든다.
  - 임의로 값을 조율하면서 테스트를 반복한다.
  - 시스템을 배치할 플랫폼 전부에서 테스트를 반복하여 계속 돌린다. 이때 테스트가 실패없이 오래 돌아간다면 시사하는 바는 아래의 두가지이다.
    - 실제 코드가 올바르다.
    - 테스트가 부족해 문제를 드러내지 못한다.
 -  이 방법을 쓰더라도 사실 쓰레드 문제를 발견할 가능성은 매우 낮다. 